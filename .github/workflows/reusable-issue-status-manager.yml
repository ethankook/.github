# Reusable workflow: issue dependency & feature rollupname: Reusable - Issue status manager (deps + rollup)

on:
  workflow_call:
    secrets:
      ORG_WORKFLOW_TOKEN:
        required: true

permissions:
  issues: write
  contents: read

jobs:
  manage:
    runs-on: ubuntu-latest

    steps:
      - name: Manage status labels and feature rollup
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_WORKFLOW_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const issue = context.payload.issue;
            if (!issue) {
              core.info("No issue in event payload; exiting.");
              return;
            }

            const issueNumber = issue.number;
            const action = context.payload.action;

            const labels = (issue.labels || []).map(l => (typeof l === "string" ? l : l.name));
            const has = (name) => labels.includes(name);

            const isTask = has("type:task");
            const isResearch = has("type:research");
            const isBug = has("type:bug");
            const isFeature = has("type:feature");

            // Only manage task/research/bug issues here (features handled only via rollup).
            if (!isTask && !isResearch && !isBug) {
              core.info("Not a task/research/bug issue; skipping dependency logic.");
              // Still allow rollup if someone accidentally triggers this? We'll skip entirely.
              return;
            }

            const STATUS_LABELS = [
              "status:backlog",
              "status:feature-in-progress",
              "status:blocked",
              "status:ready",
              "status:in-progress",
              "status:done",
            ];

            async function addLabel(name) {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: issueNumber, labels: [name],
              });
            }

            async function removeLabel(name) {
              try {
                await github.rest.issues.removeLabel({
                  owner, repo, issue_number: issueNumber, name,
                });
              } catch (e) {
                // ignore if missing
              }
            }

            async function setExclusiveStatusLabel(keep) {
              for (const s of STATUS_LABELS) {
                if (s !== keep) {
                  await removeLabel(s);
                }
              }
              await addLabel(keep);
            }

            function extractSection(body, headerText) {
              if (!body) return "";
              const lines = body.split(/\r?\n/);

              // Accept headers like "### Depends on" or "Depends on"
              const headerIdx = lines.findIndex(l =>
                l.trim().toLowerCase() === headerText.toLowerCase() ||
                l.trim().toLowerCase() === `### ${headerText.toLowerCase()}`
              );
              if (headerIdx === -1) return "";

              // Section ends at next "### " header
              const start = headerIdx + 1;
              let end = lines.length;
              for (let i = start; i < lines.length; i++) {
                if (lines[i].trim().startsWith("### ")) {
                  end = i;
                  break;
                }
              }
              return lines.slice(start, end).join("\n").trim();
            }

            function extractIssueNumbers(text) {
              if (!text) return [];
              const matches = [...text.matchAll(/#(\d+)/g)].map(m => Number(m[1]));
              // unique
              return [...new Set(matches)].filter(n => Number.isFinite(n));
            }

            function extractParentFeatureNumber(body) {
              if (!body) return null;

              // Prefer parsing within a section header if present
              const parentSection = extractSection(body, "Parent Feature Issue");
              const inSection = extractIssueNumbers(parentSection);
              if (inSection.length > 0) return inSection[0];

              // Fallback: find a nearby line containing the label
              const m = body.match(/Parent Feature Issue[^#]*#(\d+)/i);
              if (m) return Number(m[1]);

              return null;
            }

            async function isDependencyDone(depNumber) {
              const dep = await github.rest.issues.get({
                owner, repo, issue_number: depNumber,
              });

              const depLabels = (dep.data.labels || []).map(l => (typeof l === "string" ? l : l.name));
              const depHasDone = depLabels.includes("status:done");
              const depIsClosed = dep.data.state === "closed";

              return depHasDone || depIsClosed;
            }

            // -------------------------
            // (1) On close: set status:done and cleanup
            // -------------------------
            if (action === "closed") {
              core.info("Issue closed -> setting status:done and cleaning statuses.");
              await setExclusiveStatusLabel("status:done");
              // NOTE: we intentionally keep other non-status labels intact.

              // After closing, attempt feature rollup
            } else if (action === "opened" || action === "edited" || action === "reopened") {
              // -------------------------
              // (2) On opened/edited/reopened: blocked vs ready
              // -------------------------
              if (has("status:in-progress")) {
                core.info("Issue is in-progress; do not override with blocked/ready.");
              } else {
                const body = issue.body || "";
                const dependsText = extractSection(body, "Depends on");
                const deps = extractIssueNumbers(dependsText);

                // If user wrote "None" or left empty, treat as no deps
                if (deps.length === 0) {
                  core.info("No dependencies found -> status:ready");
                  await setExclusiveStatusLabel("status:ready");
                } else {
                  core.info(`Found dependencies: ${deps.join(", ")}`);
                  let anyIncomplete = false;

                  for (const dep of deps) {
                    try {
                      const done = await isDependencyDone(dep);
                      core.info(`Dependency #${dep} done? ${done}`);
                      if (!done) {
                        anyIncomplete = true;
                        break;
                      }
                    } catch (e) {
                      // If dependency can't be read, treat as incomplete to be safe
                      core.warning(`Failed to read dependency #${dep}. Treating as incomplete. Error: ${e.message}`);
                      anyIncomplete = true;
                      break;
                    }
                  }

                  if (anyIncomplete) {
                    core.info("At least one dependency incomplete -> status:blocked");
                    await setExclusiveStatusLabel("status:blocked");
                  } else {
                    core.info("All dependencies done -> status:ready");
                    await setExclusiveStatusLabel("status:ready");
                  }
                }
              }
            } else {
              core.info(`Action ${action} not handled for status manager; exiting.`);
              return;
            }

            // -------------------------
            // (3) Feature rollup (after status changes)
            // -------------------------
            const body = issue.body || "";
            const featureNumber = extractParentFeatureNumber(body);
            if (!featureNumber) {
              core.info("No Parent Feature Issue found; skipping rollup.");
              return;
            }

            // Search open children referencing the same feature number
            async function searchCount(query) {
              const res = await github.rest.search.issuesAndPullRequests({ q: query, per_page: 1 });
              return res.data.total_count || 0;
            }

            const baseQ = `repo:${owner}/${repo} is:issue is:open "Parent Feature Issue: #${featureNumber}"`;
            const openTasksQ = `${baseQ} label:"type:task"`;
            const openResearchQ = `${baseQ} label:"type:research"`;
            const openBugsQ = `${baseQ} label:"type:bug"`;

            const openTasks = await searchCount(openTasksQ);
            const openResearch = await searchCount(openResearchQ);
            const openBugs = await searchCount(openBugsQ);
            const openChildren = openTasks + openResearch + openBugs;

            core.info(`Feature #${featureNumber} has open children: ${openChildren} (tasks=${openTasks}, research=${openResearch}, bugs=${openBugs})`);

            if (openChildren > 0) {
              core.info("Open children remain; feature not complete.");
              return;
            }

            // If zero open children remain, mark feature done and archive all children (task/research/bug) that reference it.
            core.info(`No open children remain -> marking feature #${featureNumber} status:done and archiving children.`);

            // (a) mark feature status:done (exclusive among status labels)
            async function setFeatureDone() {
              // fetch feature
              const f = await github.rest.issues.get({ owner, repo, issue_number: featureNumber });
              const fLabels = (f.data.labels || []).map(l => (typeof l === "string" ? l : l.name));

              // remove any status:* labels on feature except status:done
              for (const s of STATUS_LABELS) {
                if (s !== "status:done" && fLabels.includes(s)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: featureNumber, name: s });
                  } catch {}
                }
              }
              await github.rest.issues.addLabels({ owner, repo, issue_number: featureNumber, labels: ["status:done"] });
            }

            await setFeatureDone();

            // (b) archive all children (task/research) referencing the feature
            async function listAllChildren(typeLabel) {
              const q = `repo:${owner}/${repo} is:issue "Parent Feature Issue: #${featureNumber}" label:"${typeLabel}"`;
              // search supports pagination
              let page = 1;
              const all = [];
              while (true) {
                const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 100, page });
                const items = res.data.items || [];
                all.push(...items);
                if (items.length < 100) break;
                page += 1;
              }
              return all;
            }

            const childItems = [
              ...(await listAllChildren("type:task")),
              ...(await listAllChildren("type:research")),
              ...(await listAllChildren("type:bug")),
            ];

            // de-dup (search overlap shouldn't happen, but be safe)
            const seen = new Set();
            const children = childItems.filter(i => {
              if (seen.has(i.number)) return false;
              seen.add(i.number);
              return true;
            });

            core.info(`Archiving ${children.length} child issues for feature #${featureNumber}`);

            for (const child of children) {
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: child.number, labels: ["state:archived"],
                });
              } catch (e) {
                core.warning(`Failed to archive child #${child.number}: ${e.message}`);
              }
            }