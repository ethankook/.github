name: Reusable - Project Stage sync (labels -> Stage)

on:
  workflow_call:
    inputs:
      project_number:
        required: true
        type: string
      project_name:
        required: false
        type: string
        default: Workflow
      stage_field_name:
        required: false
        type: string
        default: Stage
    secrets:
      ORG_WORKFLOW_TOKEN:
        required: true

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Sync Project Stage from labels
        uses: actions/github-script@v7
        env:
          PROJECT_NUMBER: ${{ inputs.project_number }}
          PROJECT_NAME: ${{ inputs.project_name }}
          STAGE_FIELD_NAME: ${{ inputs.stage_field_name }}
        with:
          github-token: ${{ secrets.ORG_WORKFLOW_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const issue = context.payload.issue;
            if (!issue) {
              core.info("No issue in event payload; exiting.");
              return;
            }

            const issueNumber = issue.number;
            const issueNodeId = issue.node_id;

            const labels = (issue.labels || []).map(l => (typeof l === "string" ? l : l.name)).filter(Boolean);
            const has = (name) => labels.includes(name);

            const isFeature = has("type:feature");
            const isTaskOrResearch = has("type:task") || has("type:research");

            // Stage precedence: first match wins
            // Keep this list ordered in strict priority (highest -> lowest).
            const stageMap = [
              ["state:archived", "Archive"],
              ["status:done", "Done"],
              ["status:feature-in-progress", "Feature In Progress"],
              ["status:in-progress", "In Progress"],
              ["status:blocked", "Blocked"],
              ["status:ready", "Ready"],
              ["status:backlog", "Backlog"],
            ];

            let stageValue = stageMap.find(([label]) => has(label))?.[1];

            // Feature defaults:
            // If it's a feature and no stage-driving label exists, default it to Backlog
            // so features never sit in "No stage".
            if (!stageValue && isFeature) {
              stageValue = "Backlog";
              core.info('Feature issue has no status/state label; defaulting Stage to "Backlog".');
            }

            // For tasks/research, preserve strictness (no guessing) unless they have an explicit label
            if (!stageValue && isTaskOrResearch) {
              core.info("No matching status/state label found for task/research; not guessing Stage. Exiting.");
              return;
            }

            // If it's neither feature nor task/research, keep the existing safe behavior
            if (!stageValue && !isFeature && !isTaskOrResearch) {
              core.info("Issue type not recognized (no type:* label) and no status/state label found; exiting.");
              return;
            }

            const projectNumberRaw = process.env.PROJECT_NUMBER;
            if (!projectNumberRaw) throw new Error("PROJECT_NUMBER env var missing");
            const projectNumber = Number(projectNumberRaw);
            if (!Number.isFinite(projectNumber)) throw new Error(`Invalid PROJECT_NUMBER: ${projectNumberRaw}`);

            const projectName = process.env.PROJECT_NAME || "Workflow";
            const stageFieldName = process.env.STAGE_FIELD_NAME || "Stage";

            core.info(`Repo: ${owner}/${repo}`);
            core.info(`Issue: #${issueNumber}`);
            core.info(`Project: ${projectName} (#${projectNumber})`);
            core.info(`Stage field: ${stageFieldName}`);
            core.info(`Computed Stage value: ${stageValue}`);

            // 1) Lookup org project id
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) { id title }
                }
              }`;

            const projectRes = await github.graphql(projectQuery, {
              org: owner,
              number: projectNumber,
            });

            const project = projectRes.organization?.projectV2;
            if (!project) throw new Error(\`ProjectV2 #\${projectNumber} not found in org \${owner}\`);
            const projectId = project.id;

            // 2) Find Stage field + option id
            const fieldsQuery = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 50) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }`;

            const fieldsRes = await github.graphql(fieldsQuery, { projectId });
            const fields = fieldsRes.node?.fields?.nodes || [];
            const stageField = fields.find(f => f?.name === stageFieldName);

            if (!stageField) throw new Error(\`Stage field "\${stageFieldName}" not found on project\`);

            const option = (stageField.options || []).find(o => o?.name === stageValue);
            if (!option) throw new Error(\`Stage option "\${stageValue}" not found in field "\${stageFieldName}"\`);

            const stageFieldId = stageField.id;
            const optionId = option.id;

            // 3) Add issue to project (or find existing item)
            const addItemMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                  item { id }
                }
              }`;

            let itemId;
            try {
              const addRes = await github.graphql(addItemMutation, {
                projectId,
                contentId: issueNodeId,
              });
              itemId = addRes.addProjectV2ItemById.item.id;
              core.info(\`Added issue to project. Item ID: \${itemId}\`);
            } catch (e) {
              core.info("Issue may already be in project; locating existing item...");
              const itemQuery = `
                query($owner: String!, $repo: String!, $issueNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $issueNumber) {
                      projectItems(first: 20) {
                        nodes { id project { id } }
                      }
                    }
                  }
                }`;
              const itemRes = await github.graphql(itemQuery, { owner, repo, issueNumber });
              const items = itemRes.repository?.issue?.projectItems?.nodes || [];
              const match = items.find(i => i?.project?.id === projectId);
              if (!match) throw e;
              itemId = match.id;
              core.info(\`Found existing project item. Item ID: \${itemId}\`);
            }

            // 4) Update Stage field
            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(
                  input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }
                ) {
                  projectV2Item { id }
                }
              }`;

            await github.graphql(updateMutation, {
              projectId,
              itemId,
              fieldId: stageFieldId,
              optionId,
            });

            core.info(\`âœ… Stage updated to "\${stageValue}" for issue #\${issueNumber}\`);
